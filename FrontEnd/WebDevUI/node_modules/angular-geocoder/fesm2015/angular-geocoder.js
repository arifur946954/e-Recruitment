import { Injectable, EventEmitter, Component, ViewChild, Input, Output, HostListener, NgModule } from '@angular/core';
import { HttpClient, HttpClientModule } from '@angular/common/http';
import { CommonModule } from '@angular/common';
import { FormControl, FormGroup, ReactiveFormsModule } from '@angular/forms';
import { map, filter, debounceTime, distinctUntilChanged, switchMap } from 'rxjs/operators';
import { parse } from 'terraformer-wkt-parser';

class GeocoderService {
    constructor(http) {
        this.http = http;
        this.geocoderBaseUrl = 'https://geodata.nationaalgeoregister.nl/locatieserver/v3';
    }
    suggest(query, options) {
        let params = {
            q: query,
            fq: '*',
            start: 0,
            rows: 10,
        };
        if (options) {
            params = Object.assign(params, options);
        }
        return this.http.get(`${this.geocoderBaseUrl}/suggest?`, { params: params })
            .toPromise().then((suggestResultObject) => {
            const collations = this.formatCollations(suggestResultObject.spellcheck.collations);
            const places = this.formatPlaces(suggestResultObject);
            return { collations, places };
        });
    }
    suggest$(query, options) {
        let params = {
            q: query,
            fq: '*',
            start: 0,
        };
        if (options) {
            params = Object.assign(params, options);
        }
        return this.http.get(`${this.geocoderBaseUrl}/suggest?`, { params: params })
            .pipe(map((suggestResultObject) => {
            const collations = this.formatCollations(suggestResultObject.spellcheck.collations);
            const places = this.formatPlaces(suggestResultObject);
            return { collations, places };
        }));
    }
    lookup(id, options) {
        let params = {
            id: id,
            fl: '*'
        };
        if (options) {
            params = Object.assign(params, options);
        }
        return this.http.get(`${this.geocoderBaseUrl}/lookup?`, { params: params }).toPromise().then((lookupResponse) => {
            return this.formatLookupResponse(lookupResponse);
        });
    }
    lookup$(id, options) {
        let params = {
            id: id,
            fl: '*'
        };
        if (options) {
            params = Object.assign(params, options);
        }
        return this.http.get(`${this.geocoderBaseUrl}/lookup?`, { params: params }).pipe(map((lookupResponse) => this.formatLookupResponse(lookupResponse)));
    }
    free(searchTerm, options) {
        let params = {
            q: searchTerm,
            fl: '*',
            fq: '*',
            rows: 10,
            start: 0,
        };
        if (options) {
            params = Object.assign(params, options);
        }
        return this.http.get(`${this.geocoderBaseUrl}/free?`, { params: params })
            .toPromise().then((freeResponse) => {
            return this.formatReverseResponse(freeResponse);
        });
    }
    free$(searchTerm, options) {
        let params = {
            q: searchTerm,
            fl: '*',
            fq: '*',
            rows: 10,
            start: 0,
        };
        if (options) {
            params = Object.assign(params, options);
        }
        return this.http.get(`${this.geocoderBaseUrl}/free?`, { params: params }).pipe(map((freeResponse) => this.formatReverseResponse(freeResponse)));
    }
    reverse(location, options) {
        let params = {
            type: 'adres',
            fq: '*',
            fl: '*',
            rows: 10,
            distance: 200 // meter,
        };
        if (options) {
            params = Object.assign(params, options, location);
        }
        const reverseUrl = 'https://geodata.nationaalgeoregister.nl/locatieserver/revgeo?';
        return this.http.get(reverseUrl, { params: params }).toPromise().then((reverseResponse) => {
            return this.formatReverseResponse(reverseResponse);
        });
    }
    reverse$(location, options) {
        let params = {
            type: 'adres',
            fq: '*',
            fl: '*',
            rows: 10,
            distance: 200 // meter,
        };
        if (options) {
            params = Object.assign(params, options, location);
        }
        const reverseUrl = 'https://geodata.nationaalgeoregister.nl/locatieserver/revgeo?';
        return this.http.get(reverseUrl, { params: params }).pipe(map((reverseResponse) => this.formatReverseResponse(reverseResponse)));
    }
    formatCollations(collations) {
        const parsedCollations = [];
        for (let i = 0; i < collations.length; i += 2) {
            const collation = {
                id: i,
                naam: collations[i + 1].misspellingsAndCorrections[1],
                weergavenaam: `${collations[i + 1].hits} resultaten gevonden voor <strong> ${collations[i + 1].misspellingsAndCorrections[1]} </strong>`,
                hits: collations[i + 1].hits,
            };
            parsedCollations.push(collation);
        }
        return parsedCollations;
    }
    formatPlaces(suggestResponse) {
        const places = suggestResponse.response.docs.map((place) => {
            return Object.assign(Object.assign({}, place), { highlight: suggestResponse.highlighting[place.id].suggest[0] });
        });
        return places;
    }
    /**
     * Parse WKT in lookup response.
     */
    formatLookupResponse(lookupResponse) {
        const formatted = lookupResponse.response.docs.map((lookupResult) => {
            const formattedLookupResult = lookupResult;
            if (lookupResult.centroide_ll) {
                formattedLookupResult.centroide_ll = parse(lookupResult.centroide_ll);
            }
            if (lookupResult.centroide_rd) {
                formattedLookupResult.centroide_rd = parse(lookupResult.centroide_rd);
            }
            if (lookupResult.geometrie_rd) {
                formattedLookupResult.geometrie_rd = parse(lookupResult.geometrie_rd);
            }
            if (lookupResult.geometrie_ll) {
                formattedLookupResult.geometrie_ll = parse(lookupResult.geometrie_ll);
            }
            return formattedLookupResult;
        });
        return formatted[0] || {};
    }
    formatReverseResponse(lookupResultObject) {
        const formatted = lookupResultObject.response.docs.map((reverseResult) => {
            const formattedLookupResult = reverseResult;
            if (reverseResult.centroide_ll) {
                formattedLookupResult.centroide_ll = parse(reverseResult.centroide_ll);
            }
            if (reverseResult.centroide_rd) {
                formattedLookupResult.centroide_rd = parse(reverseResult.centroide_rd);
            }
            if (reverseResult.geometrie_rd) {
                formattedLookupResult.geometrie_rd = parse(reverseResult.geometrie_rd);
            }
            if (reverseResult.geometrie_ll) {
                formattedLookupResult.geometrie_ll = parse(reverseResult.geometrie_ll);
            }
            formattedLookupResult.highlight = reverseResult.weergavenaam;
            return formattedLookupResult;
        });
        return formatted;
    }
}
GeocoderService.decorators = [
    { type: Injectable }
];
GeocoderService.ctorParameters = () => [
    { type: HttpClient }
];

// Leaflet requires the old school way for importing
class GeocoderComponent {
    constructor(geocoderService) {
        this.geocoderService = geocoderService;
        this.resultCountLimit = 10;
        this.resultFieldsToShow = [];
        this.placeFound = new EventEmitter();
        this.formattedPlaceholder = '';
        this.resultsVisible = true;
        this.places = [];
        this.collations = [];
        this.searchThreshold = 2;
        this.foundPlace = null;
        this.selectedItem = [];
        this.selectedIndex = -1;
        this.subscriptions = [];
        this.searchField = new FormControl();
        this.searchForm = new FormGroup({ search: this.searchField });
        this.subscriptions.push(this.subscribeToSearchFieldValueChanges());
    }
    clickout(event) {
        if (this.geocoderRef.nativeElement.contains(event.target)) {
            this.showResults();
        }
        else {
            this.hideResults();
        }
    }
    ngOnInit() {
        this.formattedPlaceholder = this.formatPlaceholder(this.placeholder);
    }
    ngOnChanges(changes) {
        if (changes.searchInput) {
            this.searchField.setValue(changes.searchInput.currentValue);
        }
    }
    ngOnDestroy() {
        this.subscriptions.forEach(s => s.unsubscribe());
    }
    subscribeToSearchFieldValueChanges() {
        return this.searchField.valueChanges.pipe(filter(searchInput => searchInput.length > this.searchThreshold), debounceTime(100), distinctUntilChanged(), switchMap(searchInput => this.suggest(searchInput))).subscribe(suggestResponse => {
            this.places = suggestResponse.places;
            this.collations = suggestResponse.collations;
        }); // Actual call is fired.
    }
    suggest(searchTerm) {
        const flArray = ['id', 'score', 'type', 'weergavenaam', ...this.resultFieldsToShow];
        const params = {
            fq: '*:*',
            fl: flArray.toString(),
            rows: this.resultCountLimit
        };
        if (this.type) {
            const replace = ',';
            const regex = new RegExp(replace, 'g');
            const query = this.type.replace(regex, ' OR ');
            params.fq = `type:(${query})`;
            if (this.province) {
                params.fq += ` AND provincienaam:(${this.province})`;
            }
        }
        else if (this.province) {
            params.fq = `provincienaam:(${this.province})`;
        }
        return this.geocoderService.suggest$(searchTerm, params);
    }
    free() {
        const searchTerm = this.searchField.value;
        const params = { fq: '*:*' };
        if (this.type) {
            const replace = ',';
            const regex = new RegExp(replace, 'g');
            const query = this.type.replace(regex, ' OR ');
            params.fq = `type:(${query})`;
            if (this.province) {
                params.fq += ` AND provincienaam:(${this.province})`;
            }
        }
        else if (this.province) {
            params.fq = `provincienaam:(${this.province})`;
        }
        return this.geocoderService.free$(searchTerm, params).subscribe(places => {
            this.places = places;
        });
    }
    lookup(id) {
        this.geocoderService.lookup$(id).subscribe((lookupObj) => {
            this.foundPlace = lookupObj;
            if (this.resultFieldsToShow.length > 0) {
                const input = this.resultFieldsToShow.map((resultFieldToShow) => {
                    return this.foundPlace[resultFieldToShow];
                }).join(', ');
                this.fillInput(input);
            }
            else {
                this.fillInput(this.foundPlace.weergavenaam);
            }
            this.placeFound.emit(this.foundPlace);
            this.clearPlaces();
        });
    }
    clear() {
        this.foundPlace = null;
        this.searchField.setValue('');
        this.clearPlaces();
    }
    clearPlaces() {
        this.resetIndex();
        this.places = [];
        this.collations = [];
    }
    handleEnter() {
        if (this.selectedIndex === -1) {
            return;
        }
        const selectedPlace = this.places[this.selectedIndex];
        this.lookup(selectedPlace.id);
    }
    isNoResultsFound() {
        const reachedThreshold = (this.searchField.value && this.searchField.value.length) > this.searchThreshold;
        const noSuggestions = this.places.length === 0;
        const noResult = (this.foundPlace == null);
        return (reachedThreshold) && (noSuggestions) && (noResult);
    }
    showCollations() {
        return this.collations.length > 0 && this.places.length === 0;
    }
    fillInput(content, emitEvent = false) {
        this.searchField.setValue(content, {
            emitEvent: emitEvent
        });
    }
    isHighlighted(i) {
        if (i === this.selectedIndex) {
            return true;
        }
    }
    moveUp() {
        if (this.selectedIndex > 0) {
            this.selectedIndex--;
        }
    }
    moveDown() {
        if (this.selectedIndex < this.places.length) {
            this.selectedIndex++;
        }
    }
    resetIndex() {
        this.selectedIndex = -1;
    }
    canQuery() {
        const searchInput = this.searchField.value;
        return searchInput && searchInput.length > this.searchThreshold;
    }
    canClear() {
        const searchInput = this.searchField.value;
        return searchInput && searchInput.length > 0;
    }
    formatPlaceholder(placeholder) {
        let placeholderText = 'Zoeken op de kaart...';
        if (placeholder) {
            placeholderText = placeholder;
        }
        return placeholderText;
    }
    onCollationClick(name) {
        this.fillInput(name, true);
    }
    showResults() {
        this.resultsVisible = true;
    }
    hideResults() {
        this.resultsVisible = false;
    }
}
GeocoderComponent.decorators = [
    { type: Component, args: [{
                template: "<div #geocoder (keydown.ArrowUp)=\"moveUp()\" (keydown.ArrowDown)=\"moveDown()\" (keydown.Enter)=\"handleEnter()\"\r\n  class=\"geocoder-container\">\r\n  <!-- Input -->\r\n  <div class=\"geocoder-search-container\">\r\n    <form [formGroup]=\"searchForm\">\r\n      <input (focus)=\"showResults()\" formControlName=\"search\" class=\"geocoder-search-input\" [placeholder]=\"formattedPlaceholder\" type=\"text\"\r\n        aria-label=\"Zoeken\" maxlength=\"100\">\r\n    </form>\r\n    <button class=\"searchButton\" aria-label=\"zoeken\" (click)=\"free()\" [ngClass]=\"{'highlight': canQuery()}\"> <svg\r\n        aria-hidden=\"true\" data-fa-processed=\"\" data-prefix=\"fal\" data-icon=\"search\" role=\"img\"\r\n        xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\" class=\"svg-inline--fa fa-search fa-w-16 fa-9x\">\r\n        <path fill=\"currentColor\"\r\n          d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395 312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5 0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17 0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208 32s176 78.7 176 176-78.7 176-176 176z\"\r\n          class=\"\"></path>\r\n      </svg></button>\r\n    <button class=\"closeButton\" aria-label=\"zoekopdracht verwijderen\" (click)=\"clear()\"\r\n      [ngClass]=\"{'highlight': canClear()}\"> <svg aria-hidden=\"true\" data-fa-processed=\"\" data-prefix=\"fal\"\r\n        data-icon=\"times\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 384 512\"\r\n        class=\"svg-inline--fa fa-times fa-w-12 fa-7x\">\r\n        <path fill=\"currentColor\"\r\n          d=\"M217.5 256l137.2-137.2c4.7-4.7 4.7-12.3 0-17l-8.5-8.5c-4.7-4.7-12.3-4.7-17 0L192 230.5 54.8 93.4c-4.7-4.7-12.3-4.7-17 0l-8.5 8.5c-4.7 4.7-4.7 12.3 0 17L166.5 256 29.4 393.2c-4.7 4.7-4.7 12.3 0 17l8.5 8.5c4.7 4.7 12.3 4.7 17 0L192 281.5l137.2 137.2c4.7 4.7 12.3 4.7 17 0l8.5-8.5c4.7-4.7 4.7-12.3 0-17L217.5 256z\"\r\n          class=\"\"></path>\r\n      </svg></button>\r\n  </div>\r\n  <!-- Search results-->\r\n  <div class=\"geocoder-suggestions-container\" *ngIf=\"resultsVisible === true\">\r\n    <div class=\"geocoder-suggestions-results\" *ngIf=\"places.length > 0\">\r\n      <ul class=\"geocoder-suggestions-list\">\r\n        <li class=\"geocoder-suggestion\" tabindex={{i}} *ngFor=\"let place of places; let i = index;\"\r\n          (click)=\"lookup(place.id)\" [ngClass]=\"{'focus-background': isHighlighted(i)}\">\r\n          <p *ngIf=\"resultFieldsToShow.length === 0\" class=\"geocoder-suggestion-title\" [innerHTML]=\"place.highlight\">\r\n          </p>\r\n          <p *ngIf=\"resultFieldsToShow.length > 0\" class=\"geocoder-suggestion-title\">\r\n            <ng-container *ngFor=\"let field of resultFieldsToShow\">\r\n              {{place[field]}}\r\n            </ng-container>\r\n          </p>\r\n          <p class=\"geocoder-suggestion-type\"> {{place.type}} </p>\r\n        </li>\r\n      </ul>\r\n    </div>\r\n    <div class=\"geocoder-no-results\" *ngIf=\"isNoResultsFound()\">\r\n      <p>Geen zoekresultaten gevonden voor <strong> {{searchField.value}}</strong>.</p>\r\n    </div>\r\n    <div class=\"geocoder-collation-container\" *ngIf=\"showCollations()\">\r\n      <ul class=\"geocoder-collations-list\">\r\n        <li class=\"geocoder-collation\" tabindex={{i}} (click)=\"onCollationClick(collation.naam)\"\r\n          *ngFor=\"let collation of collations; let i = index;\" [innerHTML]=\"collation.weergavenaam\">\r\n        </li>\r\n      </ul>\r\n    </div>\r\n  </div>\r\n</div>\r\n",
                selector: 'geocoder',
                styles: ["::-webkit-input-placeholder{color:#797979;font-size:14px}:-moz-placeholder,::-moz-placeholder{color:#797979;font-size:14px}:-ms-input-placeholder{color:#797979;font-size:14px}::-ms-input-placeholder{color:#797979;font-size:14px}:-moz-placeholder-shown{color:#797979;font-size:14px}:placeholder-shown{color:#797979;font-size:14px}:focus{outline:0}input,li,p,span{color:#797979;font-size:14px;margin:0}.geocoder-container{max-width:100%;position:relative;width:100%}.geocoder-search-container{background:#fff;border:none;box-shadow:0 3px 6px rgba(0,0,0,.16),0 3px 6px rgba(0,0,0,.23);width:100%}.geocoder-search-input{border:none;max-width:100%;overflow:hidden;padding:15px;width:95%;width:calc(100% - 80px)}button{cursor:pointer;position:absolute}.searchButton{background:#fff;border:none;border-right:1px solid #797979;padding-right:15px;right:50px;top:13px}.closeButton{background:#fff;border:none;margin-left:16px;right:10px;top:10px}svg{color:#797979;width:18px}.closeButton:hover svg,.highlight svg,.searchButton:hover svg{color:#79abff;transition:all .1s cubic-bezier(.075,.82,.165,1)}.geocoder-suggestions-results{background:#fff;box-shadow:0 3px 6px rgba(0,0,0,.16),0 3px 6px rgba(0,0,0,.23);max-height:400px;overflow-y:auto;position:absolute;top:53px;width:100%;z-index:1}.geocoder-collations-list,.geocoder-suggestions-list{list-style-type:none;margin:0;padding:0}.geocoder-suggestion{border-bottom:1px solid #f1f1f1;padding:15px;position:relative}.geocoder-suggestion-title{max-width:243px}.geocoder-suggestion-type{color:#bfbfbf;font-size:11px;font-weight:700;position:absolute;right:15px;text-transform:uppercase;top:36%}.geocoder-collation:hover,.geocoder-suggestion:hover{background-color:#f7f7f7;cursor:pointer}.focus-background{background-color:#f7f7f7}.geocoder-no-results{background:#fff;box-shadow:0 3px 6px rgba(0,0,0,.16),0 3px 6px rgba(0,0,0,.23);box-sizing:border-box;padding:15px;position:absolute;top:53px;width:100%;z-index:1}.geocoder-collation{z-index:1}.geocoder-collation-container{background:#fff;box-shadow:0 3px 6px rgba(0,0,0,.16),0 3px 6px rgba(0,0,0,.23);position:absolute;top:108px;width:100%;z-index:1}.geocoder-collation-container li{border-bottom:1px solid #f1f1f1;padding:15px}.searchButton{height:20px}.closeButton{height:26px}"]
            },] }
];
GeocoderComponent.ctorParameters = () => [
    { type: GeocoderService }
];
GeocoderComponent.propDecorators = {
    geocoderRef: [{ type: ViewChild, args: ['geocoder', { static: false },] }],
    type: [{ type: Input }],
    searchInput: [{ type: Input }],
    placeholder: [{ type: Input }],
    resultCountLimit: [{ type: Input }],
    resultFieldsToShow: [{ type: Input }],
    province: [{ type: Input }],
    placeFound: [{ type: Output }],
    clickout: [{ type: HostListener, args: ['document:click', ['$event'],] }]
};

class GeocoderModule {
}
GeocoderModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    HttpClientModule,
                    CommonModule,
                    ReactiveFormsModule
                ],
                exports: [GeocoderComponent],
                declarations: [GeocoderComponent],
                providers: [GeocoderService]
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { GeocoderModule, GeocoderService, GeocoderComponent as ɵa };
//# sourceMappingURL=angular-geocoder.js.map
